import subprocess
import os


def check_file(path):
    """
    Check the existence and accessibility of a file at the specified path.

    :param path: A string representing the file path to be checked.
    :type path: str

    :raises FileNotFoundError: If the file does not exist.
    :raises PermissionError: If there are permission issues when trying to open the file.
    """
    if not os.path.exists(path):
        raise FileNotFoundError(f"The file {path} does not exist.")

    if not os.path.isfile(path):
        raise FileNotFoundError(f"The path {path} exists, but it is not a file.")

    try:
        with open(path, 'r') as file:
            pass
    except PermissionError as e:
        raise PermissionError(f"Permission error while opening {path}: {e}")


def create_directory(directory_name):
    """
    Create a directory with the specified name and return its absolute path.

    :param directory_name: A string representing the name of the directory to be created.
    :type directory_name: str

    :return: The absolute path of the created directory.
    :rtype: str
    """
    if not os.path.exists(directory_name):
        os.mkdir(directory_name)

    return os.path.abspath(directory_name)


class SeqStrandSpecificityChecker:

    def __init__(self, bowtie2_directory, gene_seq, reference_genome):
        self.bowtie2_directory = bowtie2_directory
        self.gene_seq = gene_seq
        self.reference_genome = reference_genome
        self.name_index_dir = "index"

        check_file(self.reference_genome)
        check_file(self.gene_seq)

        self.index_reference_genome()

        mapped_reads = self.run_bowtie2_alignment(self.bowtie2_directory,
                                                  self.gene_seq)

        num_negative_reads, num_positive_reads = self.count_positve_and_negative_reads(mapped_reads)

        os.remove(mapped_reads)

        end_result = self.evaluate_result(num_negative_reads, num_positive_reads)

        print(end_result)

    def index_reference_genome(self):
        """
        Index the reference genome using Bowtie 2. And saves

        This function creates an index for a reference genome using Bowtie 2. The indexed files are
        generated in a newly made directory.

        :raises subprocess.CalledProcessError: If an error occurs during the execution of the 'bowtie2-build' command.
        :return: None
        """
        index_dir = create_directory(self.name_index_dir)
        os.chdir(index_dir)

        # Run the bowtie2-build command
        subprocess.run([os.path.join(self.bowtie2_directory, "bowtie2-build"), self.reference_genome, "mouse"])

        os.chdir("..")

        print("Bowtie 2 indexing completed.")

    def run_bowtie2_alignment(self, bowtie2_directory, gene_seq):
        """
        This function performs an alignment using Bowtie 2 with a reference genome index that has to
        be previously created. The alignment results are saved in a SAM format file named "result.sam"
        in the current working directory.

        :param bowtie2_directory: The path to the directory containing the Bowtie 2 executable.
        :type bowtie2_directory: str
        :param gene_seq: The path to the gene sequence file to be aligned.
        :type gene_seq: str

        :raises subprocess.CalledProcessError: If an error occurs during the execution of the Bowtie 2 alignment command.

        :return: The name of the SAM format result file generated by the alignment.
        :rtype: str
        """
        name_result_file = "result.sam"
        with open(name_result_file, "w") as file:
            pass

        bowtie2_command = (bowtie2_directory + "/bowtie2 -x " + self.name_index_dir + "/mouse" +
                           " -U " + gene_seq + " -S " + name_result_file)

        try:
            subprocess.run(bowtie2_command, shell=True, check=True)
        except subprocess.CalledProcessError as e:
            print(f"Error: {e}")

        return name_result_file

    def count_positve_and_negative_reads(self, result_file):
        """
        This function reads a SAM format result file and counts the number of positive and negative
        reads based on the second field of each SAM alignment. The interpretation of this field is
        determined according to the Bowtie 2 manual, which provides the specification for SAM flags.
        You can find the detailed flag descriptions in the Bowtie 2 manual:
        https://bowtie-bio.sourceforge.net/bowtie2/manual.shtml#sam-output

        :param result_file: The path to the SAM format result file to be analyzed.
        :type result_file: str

        :return: A tuple containing the count of negative reads and the count of positive reads.
        :rtype: tuple (int, int)
        """
        # Open the input file for reading
        with open(result_file, "r") as input_file:
            # An empty set to keep track of seen read names
            seen_read_names = set()
            paired_reads = []

            num_positive_reads = 0
            num_negative_reads = 0

            for line in input_file:
                fields = line.split('\t')
                flag = fields[1]
                if flag == "0":  # The flag bit 0x1 indicates it's a paired-end read
                    num_positive_reads = num_positive_reads + 1
                    paired_reads.append(line)
                elif flag == "16" or flag == str(16 + 64) or flag == str(16 + 1):
                    num_negative_reads = num_negative_reads + 1
                    paired_reads.append(line)
        return num_negative_reads, num_positive_reads

    def evaluate_result(self, num_negative_reads, num_positive_reads):
        """
        Evaluate the result of read alignments to determine the strand specificity.

        This function takes the counts of negative and positive reads and evaluates the result to determine the strand
        specificity of the read alignments. It returns one of the following values:

        - "Unstranded" if there are both negative and positive reads, indicating that the alignments are unstranded.
        - "Negative" if there are only negative reads, indicating a preference for the negative strand.
        - "Positive" if there are only positive reads, indicating a preference for the positive strand.

        :param num_negative_reads: The number of negative strand reads.
        :type num_negative_reads: int
        :param num_positive_reads: The number of positive strand reads.
        :type num_positive_reads: int

        :return: A string indicating the strand specificity of the read alignments.
        :rtype: str
        """
        if num_negative_reads > 0 and num_positive_reads > 0:
            return "Unstranded"
        elif num_negative_reads > 0 and num_positive_reads == 0:
            return "negative"
        elif num_negative_reads == 0 and num_positive_reads > 0:
            return "positive"
